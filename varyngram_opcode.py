from collections import *
import numpy as np
import math
import time

def getOpngram(opcodelist, n = 3):
    opngramList = [tuple(opcodelist[i:i+n]) for i in range(len(opcodelist)-n+1)]
    opngram = Counter(opngramList)
    return opngram

def updateFQNtuFQ(originFQNmap):
    n = len(originFQNmap)
    originFQmap = [dict()] * n
    for i in range(1, n):
        originFQmap[i] = dict(originFQNmap[i])
    for i in range(n-1, 1, -1):
        for k, v in originFQmap[i].iteritems():
            v = float(v) / originFQmap[i - 1][k[0:i - 1]]
            originFQmap[i][k] = v
    return originFQmap

def standardize(originFQmap):
    n = len(originFQmap)
    standardFQmap = [dict()] * n
    valuelists = [list()] * n
    value_mean_std = [list()] * n
    for i in range(1, n):
        standardFQmap[i] = dict(originFQmap[i]) # need deep copy
        valuelists[i] = list(standardFQmap[i].values())
        value_mean_std[i] = [np.mean(valuelists[i]), np.std(valuelists[i])]
        for k, v in standardFQmap[i].iteritems():
            v = (v - value_mean_std[i][0]) / value_mean_std[i][1]
            standardFQmap[i][k] = v
    return standardFQmap

def calEntropy(distribution):
    sum = 0
    for p in distribution:
        sum += - p * math.log(p, math.e)
    return sum

def calEntropyMap(originFQmap):
    originETmap = list(originFQmap)
    n = len(originFQmap)
    distributionMap = [defaultdict(list)] * n
    for i in range(2, n):
        for k, v in originFQmap[i].iteritems():
            distributionMap[i-1][k[0:i-1]].append(v)

    for i in range(1, n-1):
        for k, v in originETmap[i].iteritems():
            originETmap[i][k] = calEntropy(distributionMap[i][k])
    return originETmap

def getIndexs(score, n=3):
    indexs = []
    for i in range(len(score)):
        if score[i] >= 3:
            indexs.append(i)
    for i in range(len(indexs)):
        indexs[i] += 1
    indexs.insert(0, 0)
    indexs.append(len(score))
    return indexs

def getVaryNgram(opcodelist, n=3):

    if len(opcodelist) < n:
        return Counter()

    # FQN: Frequency Number
    originFQNmap = [Counter()] * (n+1)

    for i in range(1, n + 1):
        originFQNmap[i] = getOpngram(opcodelist, i)
    originFQmap = updateFQNtuFQ(originFQNmap)
    standardFQmap = standardize(originFQmap)

    # ET: Entro, Entropy
    originETmap = calEntropyMap(originFQmap)
    standardETmap = standardize(originETmap)

    standardFQmapSum = standardFQmap[1].copy()
    standardETmapSum = standardETmap[1].copy()
    for i in range(1,n+1):
        standardFQmapSum.update(standardFQmap[i])
        standardETmapSum.update(standardETmap[i])
    # print standardFQmapSum
    # print standardETmapSum

    score = [0] * len(opcodelist)
    for i in range(len(opcodelist)-n+1):
        # window = opcodelist[i:i+n]
        for j in range(1,n):
            formerpart = tuple(opcodelist[i:i+j])
            latterpart = tuple(opcodelist[i+j:i+n])
            frequencyExpert = [0] * (n-1)
            entropyExpert = [0] * (n-1)
            frequencyExpert[j-1] = standardFQmapSum[formerpart] + standardFQmapSum[latterpart]
            entropyExpert[j-1] = standardETmapSum[formerpart] + standardETmapSum[latterpart]
        frequencyExpertVote = frequencyExpert.index(max(frequencyExpert))
        entropyExpertVote = entropyExpert.index(max(entropyExpert))
        score[i+frequencyExpertVote] += 1
        score[i+entropyExpertVote] += 1
    print score
    indexs = getIndexs(score, n)
    varyNgramList = [tuple(opcodelist[indexs[i]:indexs[i+1]]) for i in range(len(indexs)-1)]
    varyNgram = Counter(varyNgramList)


    return varyNgram
    # return opngramlist

# varyNgram = getVaryNgram(['01','E8','B8','01','E8','B8','B8','01'])
# print varyNgram